# POST /api/reservations 500 エラー：原因と対策

## ① 500 エラーが発生する典型的な原因

| 原因 | 説明 |
|------|------|
| **Firebase Admin 未初期化・認証情報なし** | `FIREBASE_SERVICE_ACCOUNT_JSON` / `GOOGLE_APPLICATION_CREDENTIALS` が未設定で `init_firebase_admin()` が失敗する。 |
| **Firestore クライアント取得失敗** | 初期化後でも `firestore.client()` が例外を出す場合がある。 |
| **医師一覧取得時の例外** | `_get_doctors_by_department` 内の `coll.where(...).stream()` でコレクション未存在・権限・ネットワークエラー。 |
| **collectionGroup クエリ失敗** | `_has_reservation` の `collection_group("reservations")` は複合インデックスが必要。未デプロイだと例外。 |
| **doctor の型・キー不整合** | `assign_doctor` の戻りが dict でない、または `id`/`name` が無い状態で `doctor["id"]` 参照 → KeyError/TypeError。 |
| **Firestore ドキュメント path 不正** | `user_id` が空・不正文字で `document(user_id)` が失敗する（通常は 401 で弾かれる想定）。 |
| **ref.add(payload) 失敗** | 権限不足・ルール違反・payload に Firestore が受け付けない型（None 等）が含まれる。 |
| **戻り値のキー不足** | `create_reservation` の return に `id`/`departmentId` 等が無いと main の `out["departmentId"]` で KeyError → 500。 |

---

## ② create_reservation に追加すべきデバッグログ（具体例）

- **エントリ**（INFO）: `department`, `date`, `time`, `user_id` の値を 1 行でログ。
- **業務チェック通過後**（INFO）: 「過去日・祝日・今日過去時刻チェック通過」と 1 行。
- **医師取得後**（INFO）: `len(available)`, `use_demo`, `doctor is None or (id, name)` を 1 行。
- **Firestore 保存直前**（INFO）: 保存先 path（`users/{uid}/reservations`）と payload のキー一覧。
- **Firestore 保存失敗時**（ERROR + exception）: `logger.exception(...)` でトレースバック付き。
- **正常終了時**（INFO）: 作成された `doc_id` を 1 行。

これらを「原因 → 修正 → 再発防止」で追いやすくする。

---

## ③ Firestore 保存時に安全になる修正（None ガード・キー存在チェック）

- **担当医**: `doctor` が dict でない／`id`/`name` がない場合はフォールバック（`"demo"` / `"（自動割当）"`）を使い、`doctor["id"]` の直接参照をやめる。
- **ペイロード**: すべてのフィールドを `str` に統一し、**None を入れない**（空文字で埋める）。Firestore は None を許容しない場合がある。
- **保存前**: `user_id` が空でないことを再確認。path が `users/{uid}/reservations` と期待どおりであることをログで確認。
- **例外**: `ref.add(payload)` を try/except で囲み、例外時は `logger.exception` でログしてから再 raise する。

---

## ④ なぜ 400 ではなく 500 になるか

- **400** は、`create_reservation` 内で **意図的に `raise ValueError(...)` したときだけ**、main の `except ValueError as e` で捕まり `HTTPException(400, detail=str(e))` になる。「過去日」「祝日」「この時間は予約できません」など、**業務ルール違反**を 400 にしている。
- **500** は、**それ以外のすべての例外**（KeyError, TypeError, Firestore の例外、Firebase Admin の例外など）を main の `except Exception as e` で捕まえ、`HTTPException(500, detail="予約の保存に失敗しました。")` にしている。
- したがって、「想定していない不具合・環境問題・型不整合」はすべて 500 になる。今回の 500 は、上記①のいずれかが起きていると考えられる。

---

## ⑤ フロント側で追加防御すべき点

- **500 時のメッセージ表示**: `detail` が配列（Pydantic バリデーション）の場合も文字列に変換して表示する。
- **リトライ**: 500 はサーバー側不具合のため、同じ操作の即時リトライは控え、「しばらくしてから再度お試しください」と案内する。
- **送信前の再チェック**: 確認画面で「予約を確定する」クリック直前に、`selectedDate` / `time` / `department` が存在することを再度確認（既に実装済みならそのまま）。
- **二重送信防止**: 送信中はボタンを `disabled` にし、二重クリックで 500 が連続しないようにする（既に `disabled={loading}` ならそのまま）。

---

## 原因 → 修正 → 再発防止の流れ

1. **原因特定**: サーバーログの `logger.exception` 出力（トレースバック）で、`_get_firestore` / `_get_doctors_by_department` / `ref.add` のどこで例外が出たかを確認する。
2. **修正**: Firebase 認証情報の設定、Firestore ルール・インデックスのデプロイ、doctor の None ガードと Firestore ペイロードの None 排除を行う。
3. **再発防止**: 上記②のログを入れ、次に 500 が出たときに「どの段階で落ちたか」をすぐ判別できるようにする。
